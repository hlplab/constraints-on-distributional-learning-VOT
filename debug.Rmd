```{r}

get_test_data_from_stanfit(m_IA.VOT_f0_vowelduration_informedprior)
data.test <- 
  prep_data_for_IBBU_prediction(m_IA.VOT_f0_vowelduration_informedprior) %>% 
  mutate(
    # make additional rows for test block 1 so that there is 1 for each condition
    rows = ifelse(group == "no exposure", 3, 1)) %>% 
  uncount(rows) %>% 
  mutate(
    Condition.Exposure = factor(c(rep("Shift0", 9), rep("Shift10", 9), rep("Shift40", 9), c("Shift0", "Shift10", "Shift40"))),
    Block = ifelse(group != "no exposure", str_replace(group, ".*(\\d)", "\\1"), group),
    Block = factor(ifelse(group == "no exposure", 1, Block)))


d.IA_predicted_log_odds <- 
  get_IBBU_predicted_response(
      m_IA.VOT_f0_vowelduration_informedprior,
      data = data.test,
      groups = get_group_levels_from_stanfit(m_IA.VOT_f0_vowelduration_informedprior),
      logit = T)


# get the modal draw 
d.for_IA_predictions <- 
  d.IA_predicted_log_odds %>% 
  group_by(VOT, Condition.Exposure, Block) %>% 
  mode_hdci(Predicted_posterior) %>% 
  rename(Item.VOT = VOT,
         IA_predicted_logodds = Predicted_posterior)  

d.for_IA_predictions <- 
   d.for_analysis %>% 
left_join(d.for_IA_predictions, 
             by = c("Item.VOT", "Condition.Exposure", "Block")) %>% 
  mutate(Block = as.numeric(Block))


# prepare data for fit
write_csv(d.for_IA_predictions, "~/Desktop/d.for_IA_prediction_model.csv")
d.for_IA_predictions <- 
  read_csv("~/Desktop/d.for_IA_prediction_model.csv", show_col_types = FALSE)

d.for_IA_predictions %<>% 
  filter(Block %in% c(1, 3, 5, 7)) %>% 
ungroup() %>% 
  droplevels() %>% 
  drop_na()

mean_IA_posterior <- 
  mean(d.for_IA_predictions$IA_predicted_logodds, na.rm = T)
sd_IA_posterior <- 
  sd(d.for_IA_predictions$IA_predicted_logodds, na.rm = T)
mean_block <- mean(d.for_IA_predictions$Block, na.rm = T)
sd_block <- sd(d.for_IA_predictions$Block, na.rm = T)

d.for_IA_predictions %<>%
  mutate(
    IA_predicted_logodds_gs = IA_predicted_logodds - mean_IA_posterior / (2 * sd_IA_posterior),
    Block_gs = Block - mean_block / (2 * sd_block)) 


contrasts(d.for_IA_predictions$Block) <- MASS::fractions(MASS::contr.sdif(4))
dimnames(contrasts(d.for_IA_predictions$Block))[[2]] <- c("_Block2 vs. Block1", "_Block3 vs. Block2", "_Block4 vs. Block3")

contrasts(d.for_IA_predictions$Block)
d.for_IA_predictions <- 
  read_csv("~/Desktop/d.for_IA_prediction_model.csv", show_col_types = FALSE)

my_priors <- c(
  prior(student_t(3, 0, 2.5), class = "b", dpar = "mu2"),
  prior(cauchy(0, 2.5), class = "sd", dpar = "mu2"),
  prior(lkj(1), class = "cor"))

fit_test.IA_predicted_logodds <-
  brm(
  bf(
    Response.Voiceless ~ 1,
         mu1 ~ 0 + offset(0),
         mu2 ~ 1 + IA_predicted_logodds_gs + (1 + VOT_gs * Block | ParticipantID) + (1 + VOT_gs * Condition.Exposure * Block | Item.MinimalPair),
         theta1 ~ 1),
    data = d.for_IA_predictions,
    prior = my_priors,
    cores = 4,
    chains = chains,
    init = 0,
    iter = 3000,
    warmup = 1500,
    family = mixture(bernoulli("logit"), bernoulli("logit"), order = F),
    control = list(adapt_delta = .995),
    file ="~/Desktop/test-IA-logodds-prediction.rds")
```

```{r}
# simulation to check prediction of IA model 
d.responses <- 
  tibble(VOT = c(0, 45, 75), 
       N.Response = 200,
       prob = c(.15, .5, .85)) %>% 
  rowwise() %>% 
  mutate(Response.t = rbinom(1, N.Response, prob),
         Response.d = N.Response - Response.t)

# get log-odds function
m.sim <- 
tidy(glm(cbind(Response.t, Response.d) ~ 1 + VOT, family = binomial, data = d.responses))

# populate with responses
effect_condition.logodds <- 4

d.sim <- 
  expand_grid(
  Condition = c("left", "right"), 
  VOT = c(0, 45, 75),
  Block = c(1:4),
  N.Response = 200000) %>% 
  mutate(
    Response.logodds = case_when(
      Block == 1 ~ m.sim$estimate[1] + m.sim$estimate[2]*VOT,
      Block >= 1 & Condition == "left" ~ m.sim$estimate[1] + (.5 * effect_condition.logodds) + m.sim$estimate[2]*VOT,
      Block >= 1 & Condition == "right" ~ m.sim$estimate[1] - (.5 * effect_condition.logodds) + m.sim$estimate[2]*VOT),
    IA.logodds = case_when(
      Block %in% c(1, 3) ~ Response.logodds, 
      Block == 2 & Condition == "left" ~ Response.logodds - (.5 * effect_condition.logodds) * 1/2,
      Block == 2 & Condition == "right" ~ Response.logodds + (.5 * effect_condition.logodds) * 1/2,
      Block == 4 & Condition == "left" ~ Response.logodds + (.5 * effect_condition.logodds) * 1/2,
      Block == 4 & Condition == "right" ~ Response.logodds - (.5 * effect_condition.logodds) * 1/2), 
    IA.logodds_block1 = m.sim$estimate[1] + m.sim$estimate[2]*VOT,
    IA.logodds_delta = IA.logodds - IA.logodds_block1,
    Response.prob = plogis(Response.logodds)) %>% 
  rowwise() %>% 
  mutate(
    N.Response.t = rbinom(1, N.Response, Response.prob), 
    N.Response.d = N.Response - N.Response.t, 
    across(c(Block, Condition), factor))


# check IA-predicted log-odds
d.sim %>% 
  ggplot(aes(x = VOT, y = Response.logodds, linetype = Condition)) +
  geom_smooth(alpha = .3, linewidth = 1, method = "lm") +
  geom_smooth(aes(x = VOT, y = IA.logodds), method = "lm",
    alpha = .5, 
    linewidth = 1, 
    colour = "grey",
    se = F) +
  facet_wrap(~ Block, nrow = 1) +
  guides(colour = "none") +
  theme(legend.position = "top")

# logistic regression with IA.logodds as prediction
d.sim %<>% 
  ungroup() %>% 
  droplevels() %>% 
  drop_na()

contrasts(d.sim$Block) <- MASS::fractions(MASS::contr.sdif(4))
dimnames(contrasts(d.sim$Block))[[2]] <- c("_Block2 vs. Block1", "_Block3 vs. Block2", "_Block4 vs. Block3")
mean.IA.logodds <- mean(d.sim$IA.logodds) 
sd.IA.logodds <- sd(d.sim$IA.logodds)
d.sim %<>%
  mutate(Block = as.factor(Block),
         IA.logodds_gs = IA.logodds -mean.IA.logodds / (2 * sd.IA.logodds))
contrasts(d.sim$Block)

m.sim2 <- 
  glm(cbind(N.Response.t, N.Response.d) ~ 1 + IA.logodds * Block, 
      family = binomial, 
      data = d.sim)
summary(m.sim2)


# Block as linear predictor
d.sim %<>% 
  mutate(Block = as.numeric(Block))

m.sim.linearblock <- 
  glm(cbind(N.Response.t, N.Response.d) ~ 1 + IA.logodds * Block, 
      family = binomial, 
      data = d.sim)
summary(m.sim.linearblock)


m.sim.polyblock <- 
  glm(cbind(N.Response.t, N.Response.d) ~ 1 + IA.logodds * poly(Block, 2),
      family = binomial, 
      data = d.sim)
summary(m.sim.polyblock)


d.sim %<>% 
  ungroup() %>% 
  droplevels() %>% 
  drop_na()

contrasts(d.sim$Block) <- MASS::fractions(MASS::contr.sdif(4))
dimnames(contrasts(d.sim$Block))[[2]] <- c("_Block2 vs. Block1", "_Block3 vs. Block2", "_Block4 vs. Block3")
contrasts(d.sim$Condition) <- contr.sum(2)
mean.IA.logodds <- mean(d.sim$IA.logodds) 
sd.IA.logodds <- sd(d.sim$IA.logodds)

d.sim %<>%
  mutate(Block = as.factor(Block),
         IA.logodds_gs = IA.logodds -mean.IA.logodds / (2 * sd.IA.logodds))
contrasts(d.sim$Block)

m.sim.blocknested <- 
  glm(cbind(N.Response.t, N.Response.d) ~ (1 + Block * Condition) / IA.logodds, 
      family = binomial, 
      data = d.sim)
summary(m.sim.blocknested)

m.sim.blocknested <- 
  glm(cbind(N.Response.t, N.Response.d) ~ 1 +  Block / (IA.logodds_block1 + IA.logodds_delta), 
      family = binomial, 
      data = d.sim)
summary(m.sim.blocknested)

summary(glm(cbind(N.Response.t, N.Response.d) ~ (1 + Block * Condition) / VOT, 
      family = binomial, 
      data = d.sim))
 
summary(glm(cbind(N.Response.t, N.Response.d) ~ (1 + Block * Condition) / Response.logodds, 
      family = binomial, 
      data = d.sim))

d.sim %>% 
  ggplot(aes(x = IA.logodds, y = N.Response.t/(N.Response.t + N.Response.d))) +
  geom_smooth(aes(linetype = Condition), alpha = .3, linewidth = 1, method = "glm") +
  geom_smooth(colour = "black", alpha = .3, linewidth = 1, method = "glm") +
  facet_wrap(~ Block, nrow = 1) +
  guides(colour = "none") +
  theme(legend.position = "top")
```

